/**
 * API Documentation Generator
 * Genera documentación OpenAPI/Swagger desde código o estructura
 */

export interface APIEndpoint {
  method: "GET" | "POST" | "PUT" | "DELETE" | "PATCH";
  path: string;
  description?: string;
  parameters?: APIParameter[];
  requestBody?: APIRequestBody;
  responses?: APIResponse[];
}

export interface APIParameter {
  name: string;
  in: "query" | "path" | "header";
  type: string;
  required: boolean;
  description?: string;
}

export interface APIRequestBody {
  contentType: string;
  schema: any;
}

export interface APIResponse {
  status: number;
  description: string;
  schema?: any;
}

/**
 * Genera OpenAPI 3.0 spec desde endpoints
 */
export function generateOpenAPI(
  title: string,
  version: string,
  baseUrl: string,
  endpoints: APIEndpoint[]
): string {
  const paths: Record<string, any> = {};

  endpoints.forEach((endpoint) => {
    if (!paths[endpoint.path]) {
      paths[endpoint.path] = {};
    }

    const operation: any = {
      summary: endpoint.description || `${endpoint.method} ${endpoint.path}`,
      operationId: `${endpoint.method.toLowerCase()}_${endpoint.path.replace(/\//g, "_")}`,
    };

    if (endpoint.parameters && endpoint.parameters.length > 0) {
      operation.parameters = endpoint.parameters.map((param) => ({
        name: param.name,
        in: param.in,
        required: param.required,
        description: param.description,
        schema: {
          type: param.type,
        },
      }));
    }

    if (endpoint.requestBody) {
      operation.requestBody = {
        content: {
          [endpoint.requestBody.contentType]: {
            schema: endpoint.requestBody.schema,
          },
        },
      };
    }

    if (endpoint.responses && endpoint.responses.length > 0) {
      operation.responses = {};
      endpoint.responses.forEach((response) => {
        operation.responses[response.status] = {
          description: response.description,
          content: response.schema
            ? {
                "application/json": {
                  schema: response.schema,
                },
              }
            : undefined,
        };
      });
    }

    paths[endpoint.path][endpoint.method.toLowerCase()] = operation;
  });

  const spec = {
    openapi: "3.0.0",
    info: {
      title,
      version,
      description: "API documentation generated by DevToolkit",
    },
    servers: [
      {
        url: baseUrl,
        description: "API Server",
      },
    ],
    paths,
  };

  return JSON.stringify(spec, null, 2);
}

/**
 * Genera Postman Collection desde endpoints
 */
export function generatePostmanCollection(
  name: string,
  baseUrl: string,
  endpoints: APIEndpoint[]
): string {
  const items = endpoints.map((endpoint) => {
    const url = new URL(endpoint.path, baseUrl);
    
    // Agregar query parameters
    if (endpoint.parameters) {
      endpoint.parameters
        .filter((p) => p.in === "query")
        .forEach((param) => {
          url.searchParams.append(param.name, `{{${param.name}}}`);
        });
    }

    const item: any = {
      name: `${endpoint.method} ${endpoint.path}`,
      request: {
        method: endpoint.method,
        header: [],
        url: {
          raw: url.toString(),
          protocol: url.protocol.replace(":", ""),
          host: url.hostname.split("."),
          path: url.pathname.split("/").filter(Boolean),
          query: Array.from(url.searchParams.entries()).map(([key, value]) => ({
            key,
            value,
          })),
        },
        description: endpoint.description,
      },
    };

    // Agregar path parameters
    if (endpoint.parameters) {
      endpoint.parameters
        .filter((p) => p.in === "path")
        .forEach((param) => {
          if (!item.request.url.variable) {
            item.request.url.variable = [];
          }
          item.request.url.variable.push({
            key: param.name,
            value: `{{${param.name}}}`,
          });
        });
    }

    // Agregar body
    if (endpoint.requestBody) {
      item.request.body = {
        mode: "raw",
        raw: JSON.stringify(endpoint.requestBody.schema, null, 2),
        options: {
          raw: {
            language: endpoint.requestBody.contentType.includes("json")
              ? "json"
              : "text",
          },
        },
      };
    }

    return item;
  });

  const collection = {
    info: {
      name,
      schema: "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
    },
    item: items,
  };

  return JSON.stringify(collection, null, 2);
}

/**
 * Genera cURL commands desde endpoints
 */
export function generateCurlCommands(
  baseUrl: string,
  endpoints: APIEndpoint[]
): string {
  const commands = endpoints.map((endpoint) => {
    const url = new URL(endpoint.path, baseUrl);
    
    let curl = `curl -X ${endpoint.method}`;

    // Headers
    curl += ` \\\n  -H "Content-Type: application/json"`;

    // Body
    if (endpoint.requestBody) {
      const body = JSON.stringify(endpoint.requestBody.schema, null, 2);
      curl += ` \\\n  -d '${body}'`;
    }

    // URL
    curl += ` \\\n  "${url.toString()}"`;

    return `# ${endpoint.description || endpoint.path}\n${curl}\n`;
  });

  return commands.join("\n");
}

